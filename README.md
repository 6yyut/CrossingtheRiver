# CrossingtheRiver
传教士与野人渡河算法

By Jayvee

## myProject1.0
myProject1.0项目功能及注意事项：

  分别设置 传教士 和 野人 的数量，船的最大载人量为 2 时的可行方案。
  
  但是人数超过3人，可执行的方案很多，会占用大量CPU进行计算。
  
  因为没有使用线程优化，因此在计算的过程中会造成项目界面卡死情况，但不必担心，程序需要足够的时间进行计算，计算完成将展示更新结果。
  
## myProject2.0
myProject2.0项目功能及注意事项：

  设置 传教士/野人 的数量（传教士与野人数量相同），船的最大载人量自己设定，然后计算所有可行方案。
  
  与第一版一样，人数超过3人，可执行的方案很多，会占用大量CPU进行计算。
  
  因为没有使用线程优化，因此在计算的过程中会造成项目界面卡死情况，但不必担心，程序需要足够的时间进行计算，计算完成将展示更新结果。




# 实验报告

## 实验目的

理解并熟悉掌握深度优先搜索算法。

将所学人工智能理论知识综合运用到具体项目当中。

## 问题描述

　　有 N 个传教士和 N 个野人来到河边渡河，河岸有一条船，每次至多可供 k 人乘渡。问：传教士为了安全起见，应如何规划摆渡方案，使得任何时刻， 河两岸以及船上的野人数目总是不超过传教士的数目(否则不安全，传教士有可能被野人吃掉)。 即求解传教士和野人从左岸全部摆渡到右岸的过程中，任何时刻满足 M (传教土数) ≥ C 野人数)和 M+C≤k 的摆渡方案。

## 算法分析

   假设以传教士和野人的数量N为3，船一次最大的载人量K为2分析。

　　初始状态：河左岸有3个野人河3个传教士；河右岸有0个野人和0个传教士；船停在左岸，船上有0个人。

　　目标状态：河左岸有0个野人和0个传教士；河右岸有3个野人和3个传教士；船停在右岸，船上有0个人。

　　将整个问题抽象成怎样从初始状态经一系列的中间状态从而达到目标状态，状态的改变是通过划船渡河来引发的。

### 根据要求，共得出以下5中可能的渡河方案：

　　（1）渡2传教士

　　（2）渡2野人

　　（3）渡1野人1传教士

　　（4）渡1传教士

　　（5）渡1野人

　　本程序使用类来定义状态结点，使用集合存储状态结点，使用递归（深度优先查询）的思想来寻找目标状态。

## 实验内容

### 程序执行流程
　　首先，包含状态（首次为初始状态）的结构体结点（已存入结构体数组）传入处理函数，然后判断该传入结点状态是否为目标状态。

　　是则遍历打印结构体数组，打印完成之后，返回递归调用处，顺序执行之后代码（此步骤关系到是否能找到所有过河路径）；

　　否则继续判断是否该传入结点已存在于结构体数组当中，如存在，不再往下执行，返回递归调用处，顺序执行之后代码；

　　若不存在，则继续判断该传入状态的人数是否合理（是否出现人物数量小于0的情况等），若不合理，返回递归调用处，顺序执行之后代码；

　　若合理，则继续判断传教士和野人人数限制条件，即在传教士人数不为0的情况下，野人人数是否大于传教士人数，若大于则出现吃人的情况，也就是说该传入状态也不合理，则返回递归调用处，顺序执行之后代码；

　　若不满足大于条件，则说明该状态是路径转态，也就是合理的，那么进行五种渡河方案的依次变换，首先为第一种渡河方案，两个传教士过河（注意：此处的5中渡河方案没有固定顺序，也可以是其他渡河方案），那么对该传入状态的左岸和右岸的传教士人数和野人人数进行增减（若为左岸到右岸，则左岸人数减，右岸人数加，此处有一个小技巧见本段末尾）。

　　增减完成并改变船的状态（使用正负一表示，正一为左岸，负一为右岸）以后就产生了一个新的状态，将该状态存入结构体数组，之后此处又递归调用处理函数，将新产生的转态结点传入，再次进行上述条件限制判断。

　　若在该判断途中被返回至递归调用处，说明该状态不合理，则此时将已经存入结构体数组的状态结点移出结构体数组，然后程序顺序执行，进行下一个渡河方案的处理，也就是说，此时的处理是对上一个传入结点的操作（因为刚传入的已经移出了）；

　　若在判断途中未被返回至递归调用处，也就是说，传入的结点合理了，那么又开始从第一种渡河方案开始对该传入状态进行操作。

　　按照上述过程循环执行，直到出现目标状态，回到本段开头，遍历结构体数组，打印渡河路径结点信息。

　　完成以后，返回递归调用处，顺序执行之后代码，此后的操作是在寻找其他渡河路径。

　　原理为：由于该处理函数末尾存在return语句（关键），所以在找到目标状态并返回之后，目标转态结点同样会被移出结构体数组，然后在其上一个结点开始顺序往下执行操作之后的一种渡河方案，查看是否在该结点处，还有其他渡河方案可以达到目标状态，若有则同样按上述方法执行（打印输出），若执行完后面的所有渡河方案，发现都没有能够达到目标状态的结点，则会执行末尾的返回语句，返回之后，该状态结点也会被移除（关键），那么此时操作的状态结点就是上上个结点状态，对其进行其后的渡河方案操作。按照此法，不断往后退，直到所有结点都被移除，此时说明已经完成所有渡河路径的搜索（深度）。至此，本程序的执行过程叙述完毕。

　　小技巧：从左岸到右岸，和从右岸到左岸的状态变化是不一样的，前者左岸的人数减，右岸的人数加；后者左岸的人数加，右岸的人数减。我们不应单独再写程序来处理，而是应该使用船的转态带入计算来处理，注意，此技巧在于船的转态使用正负一来表示，而不应该是1和0，以及其他表示方法。为什么这么说？因为任何数乘以一，其本身都不会改变（有我也不会承认）。而正负号在此起到关键作用，我们使用正负一去乘以五种渡河方案的改变数值，从而得到的就是我们变换的正确结果，不论左岸右岸，都是正确合理的。

### 原理推导
　　上述原理完全是按照传教士和野人数量为3人，船一次的载客量最大为2为前提所得。结合上述分析不难看出，当尚未规定传教士和野人具体数量以及船一次最大载客量为多少时，与之前分析的差别仅仅在于根据人数不同，从河一端到另一端一共有多少中 载客方式，其他的原理流程与传教士和野人数量为3人，船一次的载客量最大为2的流程全部相同。
  
  
  运算结束会在“渡河方案”内显示有多少套可行方案以及每一套方案的具体渡河步骤。

　　左传：河左岸传教士人数\n左野：河左岸野人人数

　　右传：河右岸传教士人数\n右野：河右岸野人人数

　　船：船现在的位置（1：:表示船在河的左岸；-1：表示船在河的右岸）

## 实验缺陷
　　此程序仅仅实现计算效过，寻找出所有可执行方案，并未开多线程进行优化。因此当计算数据过大时，界面进程堵塞，会造成程序停止响应，不过不用担心，程序依旧在后台运算。当程序使用足够时间运行完毕后，程序将会重新响应并展示所有的可行方案！计算需要一定的时间，计算过程中请耐心等待。

## 实验总结
　　通过本次试验，掌握学会了深度优先搜索算法。

